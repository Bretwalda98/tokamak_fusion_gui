// tokamak_fusion_gui_v2.cpp
// Clean layout + interactivity + EDUCATIONAL OVERLAYS:
// - Mouse camera, presets, CSV logging, temperature controller, extra plots
// - Explain Mode (equations with live numbers), Hint Cards, Labs, Graph Probe, Help/Glossary
//
// Build (MSYS2 MinGW 64-bit):
//   g++ -O2 -std=c++17 tokamak_fusion_gui_v2.cpp -o tokamak_fusion_gui_v2.exe -lfreeglut -lglu32 -lopengl32 -lm
// Run:
//   ./tokamak_fusion_gui_v2.exe
//
// Notes: Educational toy. Physics is simplified; not for design/safety-critical use.

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <string>
#include <vector>
#include <algorithm>
#include <cctype>

#ifdef _WIN32
#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ---------- Physics params ----------
struct Params {
    // Geometry
    double R0  = 1.7;   // major radius [m]
    double a   = 0.6;   // minor radius [m]
    // Plasma
    double n_m3     = 1e20;
    double T0_keV   = 5.0;
    double Pext_Wm3 = 1e6;
    double Crad     = 0.0;
    double fracD    = 0.5;
    // Confinement
    bool   autoTau  = false;
    double tauE_s   = 1.0;
    // Auto-tau knobs (toy)
    double B0_T  = 5.3;
    double Ip_MA = 10.0;
    double kappa = 1.7;
};

static constexpr double kB        = 1.380649e-23;
static constexpr double eV        = 1.602176634e-19;
static constexpr double KperkeV   = 1.160451812e7;
static constexpr double E_DT      = 17.6e6 * eV;
static constexpr double f_alpha   = 3.5/17.6;

static const std::vector<std::pair<double,double>> dt_reactivity = {
    {  2.0,  2.0e-24},{  5.0, 1.0e-23},{ 10.0, 1.0e-22},{ 15.0, 3.0e-22},
    { 20.0,  6.0e-22},{ 30.0, 8.0e-22},{ 50.0, 1.0e-21},{100.0, 1.1e-21}
};
static inline double reactivity_DT(double T){
    T=std::max(1e-3,T);
    if(T<=dt_reactivity.front().first) return dt_reactivity.front().second;
    if(T>=dt_reactivity.back().first)  return dt_reactivity.back().second;
    for(size_t i=1;i<dt_reactivity.size();++i){
        if(T<=dt_reactivity[i].first){
            auto [T0,r0]=dt_reactivity[i-1]; auto [T1,r1]=dt_reactivity[i];
            double w=(T-T0)/(T1-T0); return r0+w*(r1-r0);
        }
    }
    return dt_reactivity.back().second;
}

static inline double torus_volume(double R0,double a){ return 2.0*M_PI*M_PI*R0*a*a; }

double tauE_auto(const Params& P, double Pheat_Wm3){
    // crude ITER-like toy scaling; clamped
    double Ip=std::max(0.1,P.Ip_MA), R=std::max(0.5,P.R0), a=std::max(0.1,P.a);
    double B=std::max(0.1,P.B0_T), n=std::max(1e18,P.n_m3), k=std::max(1.0,P.kappa);
    double Ptot = std::max(1.0, Pheat_Wm3 * torus_volume(P.R0,P.a)); // W
    double num = pow(Ip,0.93)*pow(R,1.97)*pow(a,0.58)*pow(B,0.15)*pow(n/1e19,0.41)*pow(k,0.78);
    double den = pow(Ptot/1e6,0.69);
    double tau = 0.035*num/den;                      // seconds (toy)
    return std::min(std::max(tau,0.02),20.0);
}

// ---------- App state ----------
struct State {
    Params P;
    double TkeV=0, t=0;
    bool paused=false;

    // diagnostics (density powers)
    double Pfus=0, Palpha=0, U=0, Ploss=0, Prad=0;

    // camera
    float camYaw=25.f, camPitch=15.f, camDist=4.0f;

    // graph
    static constexpr int N=900;
    std::vector<double> gt, gT, gPfus, gPloss;
    int head=0; bool wrapped=false;

    // edit panel
    bool edit=false; int sel=0; bool typing=false; std::string buf="";

    // mouse
    int mBtn=0, lastX=0, lastY=0;

    // logging
    bool logging=false; FILE* logf=nullptr;

    // controller
    bool ctrlOn=false; double targetT_keV=15.0; double Kp=2e5;

    // plot toggles
    bool showPfus=false, showPloss=false;

    // --- Education features ---
    bool explain=false;        // Explain Mode overlay
    bool showLab=false; int labIndex=0;
    bool showHelp=false;

    // Graph probe
    bool probeActive=false; int probeIdx=0;
    double probe_t=0, probe_T=0, probe_Pfus=0, probe_Ploss=0;
} S;

// Presets
struct Preset { const char* name; Params p; };
std::vector<Preset> PRESETS = {
  {"MiniTok",   []{ Params p; p.R0=1.0; p.a=0.3; p.n_m3=5e19; p.Pext_Wm3=3e5; p.tauE_s=0.3; p.T0_keV=3.0; return p; }()},
  {"LargeTok",  []{ Params p; p.R0=3.0; p.a=1.0; p.n_m3=1e20; p.Pext_Wm3=1e6; p.tauE_s=2.0; p.T0_keV=5.0; return p; }()},
  {"ITER-ish",  []{ Params p; p.R0=6.2; p.a=2.0; p.n_m3=1e20; p.B0_T=5.3; p.Ip_MA=15; p.kappa=1.7; p.autoTau=true; p.Pext_Wm3=8e5; p.T0_keV=8.0; return p; }()},
  {"DEMO-ish",  []{ Params p; p.R0=9.0; p.a=3.0; p.n_m3=1.2e20; p.B0_T=6; p.Ip_MA=20; p.kappa=1.8; p.autoTau=true; p.Pext_Wm3=6e5; p.T0_keV=10.0; return p; }()},
};

// ---------- Integration ----------
double dT_dt(double TkeV, Params& P, State& S){
    const double TK = TkeV*KperkeV;
    const double n  = P.n_m3, nD=P.fracD*n, nT=(1.0-P.fracD)*n;
    const double U  = 3.0*n*kB*TK;
    const double r  = reactivity_DT(TkeV);
    const double Pfus = nD*nT*r*E_DT;
    const double Palpha = f_alpha*Pfus;
    const double Prad = P.Crad*n*n*sqrt(std::max(1e-6,TkeV));
    const double Pheat = Palpha + P.Pext_Wm3;
    double tauE = P.autoTau ? tauE_auto(P,Pheat) : P.tauE_s;
    const double Ploss = U/std::max(1e-6,tauE);

    S.Pfus=Pfus; S.Palpha=Palpha; S.Ploss=Ploss; S.Prad=Prad; S.U=U;

    const double dUdt = Palpha + P.Pext_Wm3 - Ploss - Prad;
    return (dUdt/(3.0*n*kB))/KperkeV;
}
static inline double rk4(double T, double h, Params& P, State& S){
    double k1=dT_dt(T,P,S), k2=dT_dt(T+0.5*h*k1,P,S), k3=dT_dt(T+0.5*h*k2,P,S), k4=dT_dt(T+h*k3,P,S);
    return std::max(0.0, T + (h/6.0)*(k1+2*k2+2*k3+k4));
}

// ---------- UI helpers ----------
static inline void setViewport(int x,int y,int w,int h){ glViewport(x,y,w,h); }
static inline void drawText(float x,float y,const char* s, void* font=GLUT_BITMAP_9_BY_15){
    glRasterPos2f(x,y); for(const char* c=s; *c; ++c) glutBitmapCharacter(font,*c);
}
static inline void begin2D(int w,int h){
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_LIGHTING);
    glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity(); gluOrtho2D(0,w,0,h);
    glMatrixMode(GL_MODELVIEW);  glPushMatrix(); glLoadIdentity();
}
static inline void end2D(){
    glMatrixMode(GL_MODELVIEW);  glPopMatrix();
    glMatrixMode(GL_PROJECTION); glPopMatrix();
    glDisable(GL_BLEND);
}

void rectFilled(float x,float y,float w,float h, float a=0.6f){
    glColor4f(0,0,0,a);
    glBegin(GL_QUADS); glVertex2f(x,y); glVertex2f(x+w,y); glVertex2f(x+w,y+h); glVertex2f(x,y+h); glEnd();
    glColor3f(0.8f,0.8f,0.85f);
    glBegin(GL_LINE_LOOP); glVertex2f(x,y); glVertex2f(x+w,y); glVertex2f(x+w,y+h); glVertex2f(x,y+h); glEnd();
}

// ---------- Layout (pixels) ----------
struct Layout { int W,H;  // window
    // regions
    int R3D_x, R3D_y, R3D_w, R3D_h;
    int RGraph_x, RGraph_y, RGraph_w, RGraph_h;
    int RPanel_x, RPanel_y, RPanel_w, RPanel_h;
} L;

void computeLayout(){
    L.W = glutGet(GLUT_WINDOW_WIDTH);  L.H = glutGet(GLUT_WINDOW_HEIGHT);
    int rightW = std::max(360, L.W/4);                // right column a bit wider
    int leftW  = L.W - rightW - 16;
    int gap    = 8;
    int topH   = (int)(0.62 * L.H);
    int botH   = L.H - topH - 3*gap;

    L.R3D_x = gap;         L.R3D_y = L.H - gap - topH; L.R3D_w = leftW; L.R3D_h = topH;
    L.RGraph_x = gap;      L.RGraph_y = gap;           L.RGraph_w = leftW; L.RGraph_h = botH;
    L.RPanel_x = L.W - rightW - gap; L.RPanel_y = gap; L.RPanel_w = rightW; L.RPanel_h = L.H - 2*gap;
}

// ---------- 3D rendering ----------
void glowingMaterial(double TkeV){
    double x = std::clamp(TkeV/20.0, 0.0, 1.0);
    GLfloat c[4]={(GLfloat)(0.2+0.8*x),(GLfloat)(0.4+0.6*x),(GLfloat)1.0,1.0};
    GLfloat e[4]={(GLfloat)(0.0+1.5*x),(GLfloat)(0.2+1.2*x),(GLfloat)1.5f*(GLfloat)x,1.0};
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, e);
    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 40.0f);
}

void render3D(){
    setViewport(L.R3D_x, L.R3D_y, L.R3D_w, L.R3D_h);
    glEnable(GL_DEPTH_TEST);
    glClear(GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_PROJECTION); glLoadIdentity();
    gluPerspective(55.0, L.R3D_w/(double)std::max(1,L.R3D_h), 0.1, 100.0);
    glMatrixMode(GL_MODELVIEW); glLoadIdentity();

    glTranslatef(0,0,-S.camDist);
    glRotatef(S.camPitch,1,0,0); glRotatef(S.camYaw,0,1,0);

    glEnable(GL_LIGHTING); glEnable(GL_LIGHT0);
    GLfloat Lpos[]={2.f,3.f,4.f,1.f}, Lcol[]={0.9f,0.9f,0.9f,1.f};
    glLightfv(GL_LIGHT0, GL_POSITION, Lpos); glLightfv(GL_LIGHT0, GL_DIFFUSE, Lcol);

    // scale the torus to fit
    double R=S.P.R0, r=S.P.a; double scale = 1.5/(R+r);
    glScaled(scale,scale,scale);

    // chamber wire
    glDisable(GL_LIGHTING);
    glColor3f(0.6f,0.6f,0.65f); glutWireTorus(r, R, 22, 68);

    // plasma
    glEnable(GL_LIGHTING);
    glowingMaterial(S.TkeV);
    glutSolidTorus(r, R, 48, 128);

    // alpha "sparks"
    glDisable(GL_LIGHTING);
    glPointSize(3.f);
    glBegin(GL_POINTS);
    int n = std::min(1200, (int)(5 + 1800.0 * S.Pfus / (1e8)));
    for(int i=0;i<n;i++){
        double a1=((double)rand()/RAND_MAX)*2.0*M_PI;
        double a2=((double)rand()/RAND_MAX)*2.0*M_PI;
        double x=(R + r*cos(a2))*cos(a1);
        double y=(R + r*cos(a2))*sin(a1);
        double z= r * sin(a2);
        glColor3f(1.0f,0.9f,0.2f); glVertex3f((float)x,(float)y,(float)z);
    }
    glEnd();
}

// ---------- graph + panel ----------
void renderGraph(){
    begin2D(L.W,L.H);
    rectFilled(L.RGraph_x, L.RGraph_y, L.RGraph_w, L.RGraph_h, 0.55f);

    int cnt = S.wrapped ? State::N : S.head;
    double tmin = S.wrapped ? S.gt[S.head] : (cnt?S.gt.front():0);
    double tmax = S.wrapped ? S.gt[(S.head+State::N-1)%State::N] : (cnt?S.gt.back():1);
    if (tmax<=tmin){ tmin=S.t-1.0; tmax=S.t; }
    double Tmin=1e9,Tmax=-1e9; for(int i=0;i<cnt;i++){ Tmin=std::min(Tmin,S.gT[i]); Tmax=std::max(Tmax,S.gT[i]); }
    if(!cnt || Tmin==Tmax){ Tmin=0; Tmax=std::max(10.0,S.TkeV*1.2+1.0); }

    // axes
    glColor3f(0.8f,0.8f,0.85f);
    glBegin(GL_LINE_LOOP);
    glVertex2f(L.RGraph_x+10, L.RGraph_y+10);
    glVertex2f(L.RGraph_x+L.RGraph_w-10, L.RGraph_y+10);
    glVertex2f(L.RGraph_x+L.RGraph_w-10, L.RGraph_y+L.RGraph_h-10);
    glVertex2f(L.RGraph_x+10, L.RGraph_y+L.RGraph_h-10);
    glEnd();

    auto plotSeries = [&](const std::vector<double>& gy, float r,float g,float b){
        glColor3f(r,g,b);
        glBegin(GL_LINE_STRIP);
        for(int i=0;i<cnt;i++){
            int idx=(S.head+i)%State::N;
            float X = (float)(L.RGraph_x+10 + (L.RGraph_w-20) * ((S.gt[idx]-tmin)/std::max(1e-9,(tmax-tmin))));
            float Y = (float)(L.RGraph_y+10 + (L.RGraph_h-20) * ((gy[idx]-Tmin)/std::max(1e-9,(Tmax-Tmin))));
            glVertex2f(X,Y);
        }
        glEnd();
    };

    // data
    plotSeries(S.gT,    0.2f,0.8f,1.0f);        // T
    if(S.showPfus)  plotSeries(S.gPfus, 0.1f,1.0f,0.2f);  // Pfus (overlaid for trend)
    if(S.showPloss) plotSeries(S.gPloss,1.0f,0.6f,0.1f);  // Ploss

    // Probe (if active)
    if(S.probeActive && cnt>0){
        // map t->X
        double t = S.probe_t;
        double x = L.RGraph_x+10 + (L.RGraph_w-20) * ((t - tmin)/std::max(1e-9,(tmax-tmin)));
        x = std::clamp(x, (double)L.RGraph_x+10.0, (double)L.RGraph_x+L.RGraph_w-10.0);

        glColor3f(1,1,0.2f);
        glBegin(GL_LINES);
        glVertex2f((float)x, L.RGraph_y+10);
        glVertex2f((float)x, L.RGraph_y+L.RGraph_h-10);
        glEnd();

        // Tooltip box
        char b[256];
        float bx = (float)std::min((double)L.RGraph_x+L.RGraph_w-220.0, std::max((double)L.RGraph_x+14.0, x-100.0));
        float by = L.RGraph_y + L.RGraph_h - 70;
        rectFilled(bx, by, 210, 56, 0.75f);
        glColor3f(1,1,1);
        snprintf(b,sizeof(b),"t = %.3fs", S.probe_t);       drawText(bx+10, by+36, b);
        snprintf(b,sizeof(b),"T = %.3f keV", S.probe_T);    drawText(bx+10, by+20, b);
        snprintf(b,sizeof(b),"Pfus = %.2e, Ploss = %.2e (W/m^3)", S.probe_Pfus, S.probe_Ploss);
        drawText(bx+10, by+4, b);
    }

    // title
    glColor3f(1,1,1);
    drawText(L.RGraph_x+14, L.RGraph_y+L.RGraph_h-24, "Temperature T(keV) vs time  (F: Pfus,  L: Ploss,  Click: probe)");

    end2D();
}

void renderPanel(){
    begin2D(L.W,L.H);
    rectFilled(L.RPanel_x, L.RPanel_y, L.RPanel_w, L.RPanel_h, 0.55f);

    int x = L.RPanel_x+14, y = L.RPanel_y+L.RPanel_h-28, step = 22;

    glColor3f(1,1,1);
    drawText(x, y, "Tokamak Controls"); y -= step;

    char line[256];
    auto field = [&](const char* name, double val, int idx){
        if (S.edit && S.sel==idx) {
            glColor3f(0.2f,0.8f,1.0f);
            rectFilled(L.RPanel_x+10, y-6, L.RPanel_w-20, step, 0.3f);
            glColor3f(0,0,0);
            snprintf(line,sizeof(line), "%s: %s", name, S.typing? S.buf.c_str(): "");
            drawText(x, y, S.typing? line : (snprintf(line,sizeof(line), "%s: %.6g", name, val), line));
        } else {
            glColor3f(1,1,1);
            snprintf(line,sizeof(line), "%s: %.6g", name, val);
            drawText(x, y, line);
        }
        y -= step;
    };

    // Inputs
    field("n (m^-3)",       S.P.n_m3,     0);
    field("T0 (keV)",       S.P.T0_keV,   1);
    field("Pext (W/m^3)",   S.P.Pext_Wm3, 2);
    field("Crad",           S.P.Crad,     3);
    field("D fraction",     S.P.fracD,    4);
    field("R0 (m)",         S.P.R0,       5);
    field("a (m)",          S.P.a,        6);
    field("B0 (T)",         S.P.B0_T,     7);
    field("Ip (MA)",        S.P.Ip_MA,    8);
    field("kappa",          S.P.kappa,    9);
    field("tauE fixed (s)", S.P.tauE_s,   10);

    // Mode + live outputs
    y -= 8;
    glColor3f(1,1,0.8);
    drawText(x, y, S.P.autoTau ? "[tauE: AUTO (toy)]" : "[tauE: FIXED]"); y -= step;

    double V = torus_volume(S.P.R0,S.P.a);
    double Pfus_tot = S.Pfus*V, Pext_tot=S.P.Pext_Wm3*V;
    double Q = Pext_tot>0 ? Pfus_tot/Pext_tot : 0.0;
    double nTtau = S.P.n_m3 * S.TkeV * (S.P.autoTau ? tauE_auto(S.P, S.Palpha+S.P.Pext_Wm3) : S.P.tauE_s);

    glColor3f(0.9f,0.95f,1);
    snprintf(line,sizeof(line),"t=%.2fs  T=%.2f keV", S.t, S.TkeV); drawText(x,y,line); y-=step;
    snprintf(line,sizeof(line),"Pfus=%.2e W/m^3  Palpha=%.2e", S.Pfus, S.Palpha); drawText(x,y,line); y-=step;
    snprintf(line,sizeof(line),"Loss=%.2e  Pext=%.2e", S.Ploss, S.P.Pext_Wm3); drawText(x,y,line); y-=step;
    snprintf(line,sizeof(line),"V=%.2f m^3  Pfus_tot=%.2e W", V, Pfus_tot); drawText(x,y,line); y-=step;
    snprintf(line,sizeof(line),"Q=%.2f   nTtau=%.2e (keV·s·m^-3)", Q, nTtau); drawText(x,y,line); y-=step;

    // Controller + logging + presets
    y -= 6; glColor3f(0.9f,1.0f,0.9f);
    snprintf(line,sizeof(line),"Controller: %s  Target T=%.2f keV  Kp=%.2e  (C toggle, T set target, [ ] gain)",
             S.ctrlOn? "ON":"OFF", S.targetT_keV, S.Kp);
    drawText(x, y, line); y -= step;

    glColor3f(0.95f,0.95f,1.0f);
    snprintf(line,sizeof(line),"Logging: %s  (E toggles, file: run_log.csv)", S.logging? "ON":"OFF");
    drawText(x, y, line); y -= step;

    glColor3f(1.0f,0.95f,0.85f);
    drawText(x, y, "Presets: 1=MiniTok  2=LargeTok  3=ITER-ish  4=DEMO-ish"); y -= step;

    // Short help
    y -= 6; glColor3f(0.8f,0.9f,1.0f);
    drawText(x, y, "F1: Help/Glossary   ?: Explain Mode   H: Labs panel   G/Shift+G: next/prev lab");
    y -= step;
    drawText(x, y, "Space: Run/Pause   R: Reset   S: toggle tau mode");
    y -= step;
    drawText(x, y, "TAB: edit panel  Up/Down: select  Enter: type  Esc: cancel");
    y -= step;
    drawText(x, y, "+/-: Pext x1.1 / 0.9   Mouse: drag rotate, wheel zoom   Click graph: probe");
    y -= step;
    drawText(x, y, "F/L: toggle Pfus/Ploss in graph");

    end2D();
}

// ---------- Explain Mode ----------
void renderExplain(){
    if(!S.explain) return;
    begin2D(L.W,L.H);
    rectFilled(40, L.H-360, L.W-80, 320, 0.85f);
    int x=60, y=L.H-90, step=24; char b[256];
    glColor3f(1,1,1); drawText(x, y+30, "Explain Mode — live equations");

    double n=S.P.n_m3, T=S.TkeV, V=torus_volume(S.P.R0,S.P.a);
    double r=reactivity_DT(std::max(1e-3,T));
    double Pfus=S.Pfus, Palpha=S.Palpha, Pext=S.P.Pext_Wm3, Ploss=S.Ploss, Prad=S.Prad;
    double tauE = S.P.autoTau ? tauE_auto(S.P, Palpha+Pext) : S.P.tauE_s;

    glColor3f(0.9,0.95,1.0);
    snprintf(b,sizeof(b),"Fusion:  Pfus = n_D n_T <σv>(T) E_DT  →  %.3e W/m^3   (n=%.2e, <σv>=%.2e)", Pfus, n, r); drawText(x,y,b); y-=step;
    snprintf(b,sizeof(b),"Alpha:   Palpha = %.3f × Pfus  →  %.3e W/m^3", 3.5/17.6, Palpha); drawText(x,y,b); y-=step;
    snprintf(b,sizeof(b),"Loss:    Ploss = U/τ_E,   U = 3 n k_B T  →  τ_E = %.3g s,  Ploss = %.3e W/m^3", tauE, Ploss); drawText(x,y,b); y-=step;
    snprintf(b,sizeof(b),"Rad:     Prad ≈ C_rad n^2 √T  →  C_rad=%.2g,  Prad=%.3e W/m^3", S.P.Crad, Prad); drawText(x,y,b); y-=step;
    snprintf(b,sizeof(b),"Balance: dU/dt = Palpha + Pext − Ploss − Prad"); drawText(x,y,b); y-=step;
    snprintf(b,sizeof(b),"Volume:  V = 2π² R0 a² = %.3f m³", V); drawText(x,y,b); y-=step;
    snprintf(b,sizeof(b),"Totals:  Pfus_tot=%.3e W,  Pext_tot=%.3e W,   Q=Pfus_tot/Pext_tot", Pfus*V, Pext*V); drawText(x,y,b); y-=step;
    snprintf(b,sizeof(b),"Lawson:  nTτ = %.3e  (keV·s·m⁻³)", n*T*tauE); drawText(x,y,b); y-=step;
    glColor3f(0.8,0.9,1); drawText(x, y-6, "Tip: change one parameter at a time and watch which terms move.");
    end2D();
}

// ---------- Hint Cards (contextual help for selected field) ----------
struct Hint { const char* what; const char* eq; const char* tryit; };
Hint hints[11] = {
  {"Density n: particle count per m^3; raises fusion rate quadratically (n_D n_T).",
   "Pfus ∝ n^2 <σv>(T)",
   "Try doubling n. Watch Pfus and Palpha rise; see if τ_E loss dominates."},
  {"T0: initial temperature (keV).",
   "Sets initial U = 3 n k_B T",
   "Start low (2 keV) vs high (10 keV); compare time to steady T."},
  {"External heating power density.",
   "dU/dt term: +Pext",
   "Step +10%/+100% and observe equilibrium T shift."},
  {"Radiation coefficient (toy).",
   "Prad ≈ C_rad n^2 √T",
   "Increase Crad to see how impurities cool the plasma."},
  {"Deuterium fraction (T=1−D).",
   "Pfus ∝ n_D n_T = n^2 D(1−D)",
   "Set D=0.5 (max). Try 0.2 and 0.8; Pfus drops symmetrically."},
  {"Major radius R0.",
   "Volume V = 2π²R0a²; totals scale with V",
   "Increase R0: watch Pfus_tot and Q; τ_E(auto) changes too."},
  {"Minor radius a.",
   "Volume; also affects aspect ratio (auto-τE).",
   "Increase a: larger V, often better τ_E in toy scaling."},
  {"Toroidal field B0.",
   "τ_E(auto) has weak B exponent.",
   "Raise B0 → τ_E↑ → Ploss↓ → higher T."},
  {"Plasma current Ip.",
   "Strong τ_E(auto) exponent.",
   "Raise Ip to see improved confinement at fixed Pext."},
  {"Elongation κ.",
   "τ_E(auto) multiplier.",
   "Try 1.4→1.8; small but visible τ_E change."},
  {"Fixed τ_E (if auto off).",
   "Ploss = U/τ_E",
   "Halve τ_E to see sensitivity of T to confinement."}
};

void renderHintCard(){
    if(!S.edit) return;
    int idx = std::clamp(S.sel,0,10);
    begin2D(L.W,L.H);
    int w=L.RPanel_w-24, x=L.RPanel_x+12, y=L.RPanel_y+12, h=120;
    rectFilled(x, y, w, h, 0.7f);
    glColor3f(1,1,1);
    drawText(x+10, y+h-24, "About this parameter");
    drawText(x+10, y+h-48, hints[idx].what);
    glColor3f(0.9f,0.95f,1);  drawText(x+10, y+h-68, hints[idx].eq);
    glColor3f(0.9f,1.0f,0.9f); drawText(x+10, y+h-92, hints[idx].tryit);
    end2D();
}

// ---------- Labs (guided mini-goals) ----------
struct Lab { const char* name; const char* steps; bool (*done)(); };

bool lab1() { // Lawson milestone
    double tau = S.P.autoTau? tauE_auto(S.P,S.Palpha+S.P.Pext_Wm3):S.P.tauE_s;
    return S.P.n_m3*S.TkeV*tau >= 1e21;
}
bool lab2() { // Alpha dominance
    return S.Palpha > 0.5*S.P.Pext_Wm3;
}
bool lab3() { // Confinement study: switch fixed tau and reach steady T>5keV
    return (!S.P.autoTau && S.TkeV>5.0);
}
bool lab4() { // Geometry scaling: double volume while keeping T near start
    static double V0=-1; static double T0=-1;
    if(V0<0){ V0=torus_volume(S.P.R0,S.P.a); T0=S.TkeV; }
    double V=torus_volume(S.P.R0,S.P.a);
    return (V>=2.0*V0) && (std::fabs(S.TkeV-T0)<=2.0);
}

std::vector<Lab> LABS = {
  {"Lawson milestone", "Raise n, T, or τE until nTτ ≥ 1e21.", lab1},
  {"Alpha dominance",  "Tune Pext/T so Palpha > 0.5·Pext.",   lab2},
  {"Confinement study","Switch to fixed τE and find steady T>5 keV.", lab3},
  {"Geometry scaling", "Double V via R0/a; keep T within ±2 keV of start.", lab4},
};

void renderLab(){
    if(!S.showLab) return;
    begin2D(L.W,L.H);
    int w=420, h=120, x=L.R3D_x+16, y=L.R3D_y+L.R3D_h- h - 16;
    rectFilled(x,y,w,h,0.7f);
    glColor3f(1,1,1);
    drawText(x+10,y+h-26, LABS[S.labIndex].name);
    glColor3f(0.9f,0.95f,1);
    drawText(x+10,y+h-50, LABS[S.labIndex].steps);
    bool ok = LABS[S.labIndex].done();
    glColor3f(ok?0.6f:1.0f, ok?1.0f:0.6f, 0.6f);
    drawText(x+10,y+16, ok? "✓ Goal met" : "… Keep adjusting to meet the goal");
    end2D();
}

// ---------- Help / Glossary ----------
void renderHelp(){
    if(!S.showHelp) return;
    begin2D(L.W,L.H);
    int w=L.W-100, h=260, x=50, y=L.H-h-40;
    rectFilled(x,y,w,h,0.85f);
    glColor3f(1,1,1); drawText(x+12,y+h-24,"Help & Glossary");
    glColor3f(0.9f,0.95f,1);
    drawText(x+12,y+h-50,"Keys:  Space(run/pause), R(reset), S(τE mode), Tab(edit), Enter/Esc(typing), +/- (Pext),");
    drawText(x+12,y+h-70,"      1-4(presets), E(log CSV), C/T/[ ] (controller), F/L (plot toggles),");
    drawText(x+12,y+h-90,"      F1(help), ?(explain), H(labs), G/Shift+G(next/prev lab), Mouse drag/wheel (camera).");
    glColor3f(0.95f,0.95f,1.0f);
    drawText(x+12,y+h-120,"Q = Pfus_total / Pext_total (rough gain indicator; not net electric).");
    drawText(x+12,y+h-140,"nTτ = density × temperature × confinement time (Lawson triple product).");
    drawText(x+12,y+h-160,"<σv>(T): Maxwell-averaged fusion reactivity; increases strongly with T in D–T.");
    drawText(x+12,y+h-180,"U = 3 n k_B T: thermal energy density (ions+electrons).  Ploss = U/τ_E.");
    drawText(x+12,y+h-200,"Palpha ≈ 0.2 Pfus; Prad ~ C_rad n^2 √T (toy).");
    glColor3f(0.9f,1.0f,0.9f);
    drawText(x+12,y+20,"Educational toy: numbers are illustrative; use for intuition, not prediction.");
    end2D();
}

// ---------- main display ----------
void display(){
    computeLayout();
    glClearColor(0.02f,0.02f,0.04f,1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    render3D();
    renderGraph();
    renderPanel();
    renderHintCard();
    renderLab();
    renderExplain();
    renderHelp();

    glutSwapBuffers();
}

// ---------- ticking / data ----------
void pushGraph(){
    if ((int)S.gt.size() < State::N){
        S.gt.resize(State::N); S.gT.resize(State::N); S.gPfus.resize(State::N); S.gPloss.resize(State::N);
    }
    S.gt[S.head]=S.t;
    S.gT[S.head]=S.TkeV;
    S.gPfus[S.head]=S.Pfus;     // note: units differ from T; used for trend only
    S.gPloss[S.head]=S.Ploss;   // ditto
    S.head=(S.head+1)%State::N; if(S.head==0) S.wrapped=true;
}

void tick(int){
    if(!S.paused){
        const int steps=10; const double h=0.001;
        for(int i=0;i<steps;i++){
            S.TkeV=rk4(S.TkeV,h,S.P,S);
            S.t+=h;
        }
        // simple Pext controller to track T target
        if(S.ctrlOn){
            double err = S.targetT_keV - S.TkeV;
            S.P.Pext_Wm3 = std::max(0.0, S.P.Pext_Wm3 + S.Kp * err * 0.016); // ~ per frame
        }
        // CSV log (one row per frame)
        if(S.logging && S.logf){
            fprintf(S.logf,"%.6f,%.6f,%.6e,%.6e,%.6e,%.6e,%.6e\n",
                    S.t, S.TkeV, S.Pfus, S.Palpha, S.Ploss, S.P.Pext_Wm3, S.Prad);
            fflush(S.logf);
        }
        pushGraph();
    }
    glutPostRedisplay();
    glutTimerFunc(16,tick,0);
}

void resetSim(){
    S.TkeV=S.P.T0_keV; S.t=0; S.head=0; S.wrapped=false;
    S.gt.assign(State::N,0.0); S.gT.assign(State::N,S.TkeV);
    S.gPfus.assign(State::N,0.0); S.gPloss.assign(State::N,0.0);
    // reset lab baseline for lab4
    // (handled lazily in lab4 by static init)
}

// ---------- input ----------
void applyTyped(){
    if(!S.typing) return;
    char* end=nullptr; double v=strtod(S.buf.c_str(), &end);
    if(end==S.buf.c_str()){ S.typing=false; return; }
    switch(S.sel){
        case 0:  S.P.n_m3     = std::max(1e15, v); break;
        case 1:  S.P.T0_keV   = std::max(0.0, v);  resetSim(); break;
        case 2:  S.P.Pext_Wm3 = std::max(0.0, v);  break;
        case 3:  S.P.Crad     = std::max(0.0, v);  break;
        case 4:  S.P.fracD    = std::clamp(v,0.0,1.0); break;
        case 5:  S.P.R0       = std::max(0.2, v);  break;
        case 6:  S.P.a        = std::max(0.05, v); break;
        case 7:  S.P.B0_T     = std::max(0.1, v);  break;
        case 8:  S.P.Ip_MA    = std::max(0.1, v);  break;
        case 9:  S.P.kappa    = std::max(1.0, v);  break;
        case 10: S.P.tauE_s   = std::max(1e-3, v); break;
    }
    S.typing=false;
}

void keyboard(unsigned char key, int, int){
    if(S.typing){
        if(key==13){ applyTyped(); return; }
        if(key==27){ S.typing=false; return; }
        if(key==8 || key==127){ if(!S.buf.empty()) S.buf.pop_back(); return; }
        if((key>='0'&&key<='9')||key=='-'||key=='+'||key=='.'||key=='e'||key=='E'){ S.buf.push_back((char)key); }
        return;
    }
    switch(key){
        // app
        case 27: std::exit(0);
        case ' ': S.paused=!S.paused; break;
        case 'r': case 'R': resetSim(); break;
        // mode
        case 's': case 'S': S.P.autoTau=!S.P.autoTau; break;
        case '\t': S.edit=!S.edit; break;
        // heat tweaks
        case '+': S.P.Pext_Wm3*=1.10; break;
        case '-': S.P.Pext_Wm3*=0.90; break;
        // logging
        case 'e': case 'E':
            if(!S.logging){
                S.logf=fopen("run_log.csv","w");
                if(S.logf){ fprintf(S.logf,"t_s,T_keV,Pfus_Wm3,Palpha_Wm3,Ploss_Wm3,Pext_Wm3,Prad_Wm3\n"); S.logging=true; }
            }else{
                if(S.logf){ fclose(S.logf); S.logf=nullptr; }
                S.logging=false;
            }
            break;
        // controller
        case 'c': case 'C': S.ctrlOn=!S.ctrlOn; break;
        case 't': case 'T': S.targetT_keV = std::max(0.0, S.TkeV); break;
        case '[': S.Kp = std::max(1e3, S.Kp*0.8); break;
        case ']': S.Kp = std::min(1e9, S.Kp*1.25); break;
        // plot toggles
        case 'f': case 'F': S.showPfus=!S.showPfus; break;
        case 'l': case 'L': S.showPloss=!S.showPloss; break;
        // presets
        case '1': S.P=PRESETS[0].p; resetSim(); break;
        case '2': S.P=PRESETS[1].p; resetSim(); break;
        case '3': S.P=PRESETS[2].p; resetSim(); break;
        case '4': S.P=PRESETS[3].p; resetSim(); break;
        // education toggles
        case '?': S.explain = !S.explain; break;
        case 'h': case 'H': S.showLab = !S.showLab; break;
        case 'g':           S.labIndex = (S.labIndex+1) % (int)LABS.size(); break;
        case 'G':           S.labIndex = (S.labIndex + (int)LABS.size()-1) % (int)LABS.size(); break;
        // start typing when panel active
        case 13: if(S.edit){ S.typing=true; S.buf.clear(); } break;
    }
}

void special(int key, int, int){
    if(S.edit){
        if(key==GLUT_KEY_UP)   S.sel=(S.sel+11-1)%11;
        if(key==GLUT_KEY_DOWN) S.sel=(S.sel+1)%11;
        if(key==GLUT_KEY_F1)   S.showHelp=!S.showHelp;
        return;
    }
    switch(key){
        case GLUT_KEY_LEFT:  S.camYaw -= 3.f; break;
        case GLUT_KEY_RIGHT: S.camYaw += 3.f; break;
        case GLUT_KEY_UP:    S.camDist = std::max(1.8f, S.camDist-0.1f); break;
        case GLUT_KEY_DOWN:  S.camDist = std::min(7.0f, S.camDist+0.1f); break;
        case GLUT_KEY_F1:    S.showHelp=!S.showHelp; break;
    }
}

// Mouse controls + Graph Probe
void mouse(int button, int state, int x, int y){
    // GLUT's y=0 is top in our 2D setup? (We used orthographic 0..H bottom-origin)
    // Here, y is top-origin; convert to bottom-origin when comparing with rectangles.
    int y_bottom = L.H - y;

    if(state==GLUT_DOWN){
        // If clicking inside the graph rectangle → set probe instead of rotating camera.
        if(button==GLUT_LEFT_BUTTON &&
           x >= L.RGraph_x+10 && x <= L.RGraph_x+L.RGraph_w-10 &&
           y_bottom >= L.RGraph_y+10 && y_bottom <= L.RGraph_y+L.RGraph_h-10)
        {
            int cnt = S.wrapped ? State::N : S.head;
            if(cnt>0){
                double tmin = S.wrapped ? S.gt[S.head] : S.gt.front();
                double tmax = S.wrapped ? S.gt[(S.head+State::N-1)%State::N] : S.gt[std::max(0,S.head-1)];
                if (tmax<=tmin){ tmin=S.t-1.0; tmax=S.t; }
                double u = (x - (L.RGraph_x+10.0)) / (double)(L.RGraph_w-20.0);
                u = std::clamp(u, 0.0, 1.0);
                double t_click = tmin + u*(tmax-tmin);

                // find nearest index in ring buffer
                int best=-1; double bestd=1e100;
                for(int i=0;i<cnt;i++){
                    int idx=(S.head+i)%State::N;
                    double d=std::fabs(S.gt[idx]-t_click);
                    if(d<bestd){bestd=d; best=idx;}
                }
                if(best>=0){
                    S.probeActive=true; S.probeIdx=best;
                    S.probe_t = S.gt[best];
                    S.probe_T = S.gT[best];
                    S.probe_Pfus = S.gPfus[best];
                    S.probe_Ploss= S.gPloss[best];
                }
            }
            return; // don't set mBtn; this was a probe click
        }
        // otherwise: camera drag
        S.mBtn=button; S.lastX=x; S.lastY=y;
    } else {
        S.mBtn=0;
    }
}

void motion(int x, int y){
    if(S.mBtn==GLUT_LEFT_BUTTON){
        S.camYaw   += (x - S.lastX)*0.4f;
        S.camPitch += (y - S.lastY)*0.3f;
        S.camPitch = std::clamp(S.camPitch, -85.f, 85.f);
        S.lastX=x; S.lastY=y;
    }
}
void mouseWheel(int wheel, int dir, int x, int y){
    (void)wheel; (void)x; (void)y;
    if(dir>0) S.camDist = std::max(1.6f, S.camDist-0.2f);
    else      S.camDist = std::min(7.0f, S.camDist+0.2f);
}

int main(int argc, char** argv){
    S.P = Params{}; S.TkeV=S.P.T0_keV;

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGBA|GLUT_DOUBLE|GLUT_DEPTH);
    glutInitWindowSize(1280,760);
    glutCreateWindow("0D Tokamak Fusion — GUI + 3D (toy, interactive + educational)");

    glEnable(GL_COLOR_MATERIAL);
    glShadeModel(GL_SMOOTH);

    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard);
    glutSpecialFunc(special);
    glutMouseFunc(mouse);
    glutMotionFunc(motion);
#ifdef GLUT_MOUSEWHEEL_FUNC
    glutMouseWheelFunc(mouseWheel);
#endif
    glutTimerFunc(16,tick,0);

    resetSim();
    glutMainLoop();
    return 0;
}
